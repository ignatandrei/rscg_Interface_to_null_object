@inherits RazorBlade.PlainTextTemplate<rscg_Interface_to_null_object.DataFromExposeInterface>
@{
    string nameClass = Model.Name.StartsWith("I")?Model.Name.Substring(1):Model.Name;
    nameClass += "_null";

}
// <auto-generated>
    //     This code was generated by a tool :@Generated.rscg_Interface_to_null_object.TheAssemblyInfo.AssemblyName
    //     Runtime Version: @Generated.rscg_Interface_to_null_object.TheAssemblyInfo.GeneratedNameNice
    //     DateOfTool : @Generated.rscg_Interface_to_null_object.TheAssemblyInfo.DateGeneratedUTC.ToString("yyyy-MM-dd HH:mm:ss")
    //     Changes to this file may cause incorrect behavior and will be lost if
    //     the code is regenerated.
    // </auto-generated>
//------------------------------------------------------------------------------
/// <summary>
    /// This static partial class contains extension methods for sorting collections of @Model.Name objects.
    /// </summary>

#nullable enable
#pragma warning disable CS8603
#pragma warning disable CS8625
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[global::System.CodeDom.Compiler.GeneratedCode("GeneratorName","@Generated.rscg_Interface_to_null_object.TheAssemblyInfo.DateGeneratedUTC.ToString("yyyy.1MMdd.1HHmm.1ss")")]
@Model.DebuggerDisplay()
public partial class @(nameClass) : @((Model.hasInterface) ?  Model.NameClassFromInterface +",": "") @Model.FullName
{
public static bool PropertiesAreEqual(@Model.FullName v1, @Model.FullName v2){
    try{
@foreach (var prop in Model.props)
{
    <text>
        if(v1.@prop.Name != v2.@prop.Name) return false;
    </text>
}
@if (Model.hasInterface)
{
    <text>
        return PropertiesAreEqual(v1 as  @Model.NameInterfaceInherited ,v2 as  @Model.NameInterfaceInherited);
    </text>
}
else
{
    <text>
        return true;
    </text>
}
    }
    catch (System.Exception ex)
    {
        return false;
    }

}
public static void CopyProperties(@Model.FullName source , @Model.FullName destination){

@foreach (var prop in Model.props)
{
    <text>
        destination.@prop.Name = source.@prop.Name;
    </text>
}
@if (Model.hasInterface)
{
    <text>
        CopyProperties(source as  @Model.NameInterfaceInherited ,destination as  @Model.NameInterfaceInherited);
    </text>
}

}
public bool PropertiesAreEqual(@Model.FullName data){
return PropertiesAreEqual(data, this);
}
public void CopyPropertiesFrom(@Model.FullName data){
CopyProperties(data, this);
}
public void CopyPropertiesTo(@Model.FullName data){
CopyProperties(this,data);
}

@foreach(var prop in Model.props){
    <text>
        public virtual @prop.Type @prop.Name { get; set; } = default(@prop.Type);
    </text>
}
@foreach (var func in Model.functions)
{
    string ret = Model.DefaultValueReturnFunc(func);
    string helpVisible = Model.HelpVisible(func);
    string startReturn = $"<I2NO_{helpVisible}>";
    string endReturn = $"</I2NO_{helpVisible}>";

    <text>
        /*
        To replace the default value, put
        <ItemGroup>
            <CompilerVisibleProperty Include="@("I2NO_"+helpVisible)" />
        </ItemGroup>
        <PropertyGroup>
            @(startReturn) return whatever you want @(endReturn)
        </PropertyGroup>
        */
        public virtual @func.ReturnType @Model.DisplayFunc(func) {  
@(ret) ; }
    </text>
}

}


public class @(Model.Name + "Converter") : System.Text.Json.Serialization.JsonConverter<@(Model.FullName)>
    {
    public override @Model.FullName Read(ref System.Text.Json.Utf8JsonReader reader, System.Type typeToConvert, System.Text.Json.JsonSerializerOptions options)
    {
    // Deserialize the JSON to the concrete type @Model.Name
    return System.Text.Json.JsonSerializer.Deserialize<@nameClass>
        (ref reader, options);
        }

        public override void Write(System.Text.Json.Utf8JsonWriter writer, @Model.FullName value, System.Text.Json.JsonSerializerOptions options)
        {
        // Serialize the concrete type @Model.Name
        System.Text.Json.JsonSerializer.Serialize(writer, (@nameClass)value, options);
        }
        }


#nullable restore
#pragma warning restore CS8603
#pragma warning restore CS8625